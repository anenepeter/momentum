## **Modern Flutter Best Practices for VS Code's Copilot (2025)**

These guidelines adapt and modernize best practices for Flutter development, focusing on performance, maintainability, contemporary libraries, and emerging standards, optimized for use with VS Code's Copilot.

## **1\. Application Structure & Modularity**

### **Project Organization (Standard)**

lib/  
├── core/                 \# Core functionalities (shared across features)  
│   ├── constants/        \# App-wide constants  
│   ├── di/               \# Dependency injection setup (e.g., GetIt)  
│   ├── error/            \# Error handling classes/utilities  
│   ├── navigation/       \# Routing setup (e.g., GoRouter)  
│   ├── network/          \# Base network client, interceptors  
│   ├── theme/            \# App theme data  
│   └── utils/            \# General utilities  
├── features/             \# Feature modules (see below)  
├── shared/               \# Widgets/Models/Utils shared by multiple features  
│   ├── widgets/  
│   ├── models/  
│   └── utils/  
├── config/               \# Configuration files (environment-specific)  
├── generated/            \# Generated code (e.g., Freezed, localization) \- DO NOT EDIT MANUALLY  
└── main.dart             \# Application entry point

### **Feature-First Organization (Recommended for Larger Apps)**

Organize by feature, promoting modularity. Consider using Melos for managing multi-package monorepos.  
lib/  
├── features/  
│   ├── auth/  
│   │   ├── data/          \# Data layer: models, repositories, data sources (local/remote)  
│   │   │   ├── models/  
│   │   │   ├── repositories/  
│   │   │   └── sources/  
│   │   ├── domain/        \# Domain layer: use cases/interactors (optional, for complex logic)  
│   │   │   └── usecases/  
│   │   ├── presentation/  \# Presentation layer: UI and state management  
│   │   │   ├── screens/     \# Feature screens  
│   │   │   ├── widgets/     \# Feature-specific widgets  
│   │   │   └── manager/     \# State management (stores, providers, blocs)  
│   │   └── feature\_exports.dart \# Barrel file exporting necessary parts of the feature  
│   └── products/  
│       ├── data/  
│       ├── domain/  
│       └── presentation/  
├── core/                 \# (As above)  
├── shared/               \# (As above)  
├── config/               \# (As above)  
├── generated/            \# (As above)  
└── main.dart             \# (As above)

## **2\. Widget Creation Guidelines**

### **When to Create a New Widget**

* **Reusability:** UI element needed in multiple places.  
* **Complexity:** Build method exceeds \~50-70 lines or has significant nesting (\> 4-5 levels).  
* **Responsibility:** Section has a distinct purpose or state.  
* **State Management:** Isolate stateful logic (e.g., StatefulWidget, ConsumerWidget).  
* **Readability:** Improve clarity by breaking down large build methods.  
* **Testability:** Easier to test smaller, focused widgets.  
* **Performance:** Optimize rebuilds by isolating parts of the UI (const widgets, RepaintBoundary).

### **When NOT to Create a New Widget**

* **Triviality:** Used only once and very simple (\< 15-20 lines).  
* **Over-Granularity:** A single styled Text or simple Container without unique logic.  
* **Premature Abstraction:** Breaking down simple layouts just for file size (use private helper methods \_buildSection() first).

### **Widget Types**

* **StatelessWidget**: Default choice. Use when UI depends only on constructor args and BuildContext. Make immutable.  
* **StatefulWidget**: Use when UI changes based on internal state or requires lifecycle methods (initState, dispose). Keep state minimal.  
* **ConsumerWidget** / **HookWidget** (Riverpod/Hooks): Preferred for interacting with state management.  
* **CustomPainter** / **CustomMultiChildLayout**: For complex custom drawing or layout needs.  
* **RenderObjectWidget**: Advanced use cases requiring direct manipulation of the render tree.

## **3\. State Management (Riverpod Focus)**

### **Store Organization**

* **Feature-Based:** Place providers/notifiers within their respective feature's presentation/manager directory.  
* **Granularity:** Prefer smaller, focused providers over large monolithic ones.  
* **Naming:** Use clear names (e.g., authServiceProvider, userNotifierProvider).

### **Keep Stores Focused & Declarative**

* **Single Responsibility:** Each provider/notifier manages a specific piece of state or logic.  
* **Immutability:** Use immutable state objects (e.g., generated by freezed). Modify state by creating new instances (state \= state.copyWith(...)).  
* **Separate Concerns:** Keep UI logic out of repositories/services. State notifiers handle presentation logic and interact with domain/data layers.  
* **Selectors:** Use ref.watch(provider.select((state) \=\> state.value)) to rebuild only when specific parts of the state change.

### **Modern Riverpod Patterns (using Code Generation)**

// user\_notifier.dart  
import 'package:riverpod\_annotation/riverpod\_annotation.dart';  
import 'package:freezed\_annotation/freezed\_annotation.dart';  
import 'user\_model.dart'; // Assume Freezed model  
import 'user\_repository.dart'; // Assume repository interface

part 'user\_notifier.g.dart'; // Generated file  
part 'user\_notifier.freezed.dart'; // Generated file

@freezed  
class UserState with \_$UserState {  
  const factory UserState.initial() \= \_Initial;  
  const factory UserState.loading() \= \_Loading;  
  const factory UserState.data(User user) \= \_Data;  
  const factory UserState.error(String message) \= \_Error;  
}

// AutoDispose keeps the state alive only while listened to  
@riverpod // Generates userNotifierProvider  
class UserNotifier extends \_$UserNotifier {  
  // Dependencies are automatically injected by Riverpod  
  late final UserRepository \_repository \= ref.watch(userRepositoryProvider);

  @override  
  UserState build() {  
    // Initial state determination logic (can be sync or async)  
    return const UserState.initial();  
  }

  Future\<void\> fetchUser(int id) async {  
    state \= const UserState.loading();  
    try {  
      final user \= await \_repository.fetchUser(id);  
      state \= UserState.data(user);  
    } catch (e, stackTrace) {  
      // Log the error (see Error Handling section)  
      ref.read(talkerProvider).handle(e, stackTrace, 'Failed to fetch user');  
      state \= UserState.error(e.toString()); // Provide user-friendly message  
    }  
  }

  void clearUser() {  
    state \= const UserState.initial();  
  }

  void updateUser(User updatedUser) {  
    // Optimistic update example  
    if (state is \_Data) {  
      final previousState \= state as \_Data;  
      state \= UserState.data(updatedUser); // Update UI immediately  
      try {  
        await \_repository.updateUser(updatedUser);  
        // Optional: refresh or confirm success  
      } catch (e, stackTrace) {  
        ref.read(talkerProvider).handle(e, stackTrace, 'Failed to update user');  
        state \= previousState; // Revert on error  
        // Optionally show error message  
      }  
    }  
  }  
}

* **Other Options:** Bloc/Cubit remain solid choices, especially for event-driven state machines. Provider is simpler for basic dependency injection and state propagation.

## **4\. Navigation (GoRouter)**

* **Declarative:** Use GoRouter for type-safe, declarative routing.  
* **Configuration:** Define routes in a dedicated file (core/navigation/app\_router.dart).  
* **Type Safety:** Pass arguments as typed objects, not just strings/maps.  
* **Deep Linking:** Simplifies handling deep links and navigation state restoration.  
* **Redirection:** Implement authentication guards and redirects easily.

// core/navigation/app\_router.dart  
import 'package:go\_router/go\_router.dart';  
import 'package:riverpod/riverpod.dart';  
// ... import screens and providers

final routerProvider \= Provider\<GoRouter\>((ref) {  
  final authState \= ref.watch(authNotifierProvider); // Example auth state

  return GoRouter(  
    initialLocation: '/splash',  
    debugLogDiagnostics: true, // Enable for debugging  
    routes: \[  
      GoRoute(  
        path: '/splash',  
        builder: (context, state) \=\> const SplashScreen(),  
      ),  
      GoRoute(  
        path: '/login',  
        builder: (context, state) \=\> const LoginScreen(),  
      ),  
      GoRoute(  
        path: '/home',  
        builder: (context, state) \=\> const HomeScreen(),  
        routes: \[ // Nested routes  
          GoRoute(  
            path: 'profile', // Becomes /home/profile  
            builder: (context, state) \=\> const ProfileScreen(),  
          ),  
          GoRoute(  
            path: 'products/:id', // Path parameter  
            builder: (context, state) {  
              final id \= state.pathParameters\['id'\]\!;  
              return ProductDetailsScreen(productId: id);  
            },  
          ),  
        \],  
      ),  
      // ... other routes  
    \],  
    redirect: (context, state) {  
      final loggingIn \= state.matchedLocation \== '/login';  
      final isSplash \= state.matchedLocation \== '/splash';

      // Check auth state (this is a simplified example)  
      final isLoggedIn \= authState.maybeWhen(  
        authenticated: (\_) \=\> true,  
        orElse: () \=\> false,  
      );

      if (isSplash) return null; // Allow splash screen always  
      if (\!isLoggedIn && \!loggingIn) return '/login'; // Redirect to login if not logged in  
      if (isLoggedIn && loggingIn) return '/home'; // Redirect to home if logged in and on login page

      return null; // No redirect needed  
    },  
  );  
});

// In main.dart MaterialApp.router  
MaterialApp.router(  
  routerConfig: ref.watch(routerProvider),  
  // ... other config  
)

## **5\. Dependency Injection (GetIt)**

* **Centralized Setup:** Use get\_it for managing dependencies (repositories, services, etc.).  
* **Service Locator:** Provides a simple way to access registered instances.  
* **Abstraction:** Decouples classes from concrete implementations.  
* **Setup:** Configure in core/di/service\_locator.dart and call during app initialization.

// core/di/service\_locator.dart  
import 'package:get\_it/get\_it.dart';  
import 'package:http/http.dart' as http;  
// ... import repositories, services

final sl \= GetIt.instance; // Service Locator instance

Future\<void\> setupLocator() async {  
  // External Dependencies  
  sl.registerLazySingleton(() \=\> http.Client());

  // Core Services  
  sl.registerLazySingleton\<ApiClient\>(() \=\> ApiClient(sl())); // Depends on http.Client

  // Repositories (Abstract behind interfaces)  
  sl.registerLazySingleton\<AuthRepository\>(() \=\> AuthRepositoryImpl(sl()));  
  sl.registerLazySingleton\<ProductRepository\>(() \=\> ProductRepositoryImpl(sl()));

  // Use Cases / Interactors (Optional)  
  sl.registerFactory(() \=\> LoginUseCase(sl())); // Factory for short-lived objects

  // Providers/Notifiers can access dependencies via sl or Riverpod's ref.read  
}

// In main.dart before runApp  
await setupLocator();  
runApp(const ProviderScope(child: MyApp()));

## **6\. UI and Styling Guidelines**

### **Keep Widget Trees Simple & Performant**

* **Nesting Depth:** Aim for max 5-6 levels. Refactor complex builds using helper methods (\_buildSection) or dedicated widgets.  
* **const**: Use const religiously for widgets, constructors, and values that don't change. This is crucial for performance.  
* **Layout Widgets:** Master Row, Column, Stack, Expanded, Flexible, Wrap, ListView, GridView, CustomScrollView.  
* **Avoid IntrinsicWidth/Height:** Use sparingly as they can be expensive.  
* **BuildContext** Awareness: Avoid passing BuildContext down unnecessarily. Use state management or DI to provide data/services. Access theme/mediaquery locally: Theme.of(context), MediaQuery.of(context).

### **Styling Best Practices**

* **ThemeData**: Define a comprehensive theme in core/theme/app\_theme.dart (colors, typography, button themes, input decoration themes). Use Theme.of(context) extensively.  
* **Consistency:** Use theme values (textTheme.bodyMedium, colorScheme.primary) instead of hardcoded styles.  
* **Reusable Styles:** Extract common TextStyle or BoxDecoration into constants or theme extensions.  
* **Responsiveness:** Use LayoutBuilder, MediaQuery, and packages like flutter\_screenutil for adaptive UIs.  
* **SafeArea**: Apply at the screen level to avoid system intrusions.  
* **Spacing:** Use SizedBox, Padding, Spacer consistently. Define standard spacing values in constants (AppDimens.paddingMedium).  
* **ClipRRect** / **ClipOval**: Use for clipping widgets (e.g., rounded image corners).

## **7\. Code Generation**

* **freezed**: Use for immutable data classes, state objects, and unions (sealed classes). Reduces boilerplate and ensures correctness.  
* **json\_serializable**: Generate fromJson/toJson methods for models used with APIs.  
* **riverpod\_generator**: Generate providers automatically, reducing boilerplate for Riverpod.  
* **build\_runner**: The tool used to run code generation (flutter pub run build\_runner build \--delete-conflicting-outputs).

## **8\. Error Handling & Logging**

* **Structured Logging:** Use a robust logging package like talker or logger. Configure different log levels and outputs (console, file, remote service).  
* **Centralized Handling:** Catch errors at logical boundaries (API calls, state updates). Use try-catch blocks.  
* **User Feedback:** Translate errors into user-friendly messages or UI states. Don't expose raw error details to the user.  
* **Error Reporting:** Integrate with services like Sentry or Firebase Crashlytics for production error monitoring.  
* **Talker Example:**

// core/di/service\_locator.dart (or a dedicated logging setup)  
import 'package:talker\_flutter/talker\_flutter.dart';

// ... inside setupLocator()  
sl.registerSingleton\<Talker\>(TalkerFlutter.init());

// Accessing Talker (e.g., via Riverpod provider or direct sl lookup)  
final talkerProvider \= Provider\<Talker\>((ref) \=\> sl\<Talker\>());

// Usage in a notifier or service  
try {  
  // ... risky operation  
} catch (e, stackTrace) {  
  ref.read(talkerProvider).handle(e, stackTrace, 'Error during operation X');  
  // ... update state to show error  
}

## **9\. Testing Strategies**

* **Unit Tests (test package):**  
  * Test individual functions, methods, or classes in isolation (Models, Utilities, Notifiers/Blocs logic, Repositories with mocking).  
  * Use mocking frameworks (mockito, mocktail) to isolate dependencies.  
  * Focus on business logic and edge cases.  
* **Widget Tests (flutter\_test package):**  
  * Test individual widgets in isolation or small compositions.  
  * Verify UI rendering, interactions (tapping, scrolling), and state changes.  
  * Use tester.pumpWidget, find, expect, tester.tap.  
  * Mock dependencies (providers, services) needed by the widget.  
* **Integration Tests (integration\_test package):**  
  * Test complete features or user flows running on a real device or emulator.  
  * Verify interactions between multiple widgets, screens, and services.  
  * Slower than unit/widget tests, use for critical paths.

## **10\. Code Elegance & Maintainability**

### **Simplicity Principles**

* **Function/Method Length:** Aim for \< 20-30 lines.  
* **Widget Build Length:** Aim for \< 70-100 lines (use helper methods/widgets).  
* **Class Length:** Keep classes focused; avoid god classes.  
* **Parameters:** \< 5-7 constructor parameters (use data classes or builders).  
* **Nesting:** Avoid deep nesting (\> 3-4 levels) in logic (if/else, loops).  
* **Readability:** Use clear variable/function names, add comments for *why*, not *what*.  
* **Null Safety:** Leverage Dart's sound null safety (?, \!, late, required). Avoid \! where possible.

### **Asynchronous Programming**

* **async**/**await**: Use for clear asynchronous workflows.  
* **Error Handling:** Always handle errors in Futures using try-catch or .catchError().  
* **Future.wait**: Run multiple futures concurrently when results are independent.  
* **Stream**s: Use for sequences of asynchronous events. Remember to cancel subscriptions (StreamSubscription.cancel()) in dispose. Riverpod handles this automatically for providers.

### **Code Organization**

* **File Naming:** Use snake\_case (e.g., user\_repository.dart).  
* **Class Naming:** Use PascalCase (e.g., UserNotifier).  
* **Imports:** Organize imports (Dart/Flutter \-\> Packages \-\> Project). Use relative imports within the same feature/package.  
* **final** vs **const**: Use const where possible (compile-time constants). Use final for runtime constants or variables assigned only once.  
* **Linting:** Enable and configure strict linting rules (analysis\_options.yaml) using packages like flutter\_lints or lints.